<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>eTRU Metrics</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      background: rgb(255, 255, 255);
      margin: 0;
      padding: 0;
      color: #2b2f32;
    }

    .header-banner {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      width: 100%;
      background-color: #f5f6f6;
      color: #2b2f32;
      padding: 10px 16px;
      border-bottom: 1.75px solid #dbe2ea;
    }

    .header-banner h1 {
      margin: 0;
      font-size: 1.8rem;
      font-weight: 300;
    }

    .dashboard-container {
      max-width: 1450px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    .facilitySelectorCommonComponent {
      display: flex;
      align-items: center;
      margin: 2rem 0;
      gap: 1rem;
      font-size: 1.75rem;
      font-weight: 300;
    }

    .dashboard-section {
      margin: 1rem 0;
    }

    .section-header {
      font-size: 1.75rem;
      color: #2b2f32;
      margin: 0 0 1rem;
      font-weight: 300;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid #dbe2ea;
    }

    .card-container {
      display: flex;
      flex-wrap: wrap;
      gap: .75rem;
      margin: 1rem 0;
      justify-content: flex-start;
    }

    .metric-card {
      background: #ffffff;
      border-radius: 14px;
      border: 14px solid rgb(206, 206, 206);
      box-shadow: none;
      padding: 1.5rem 2rem;
      flex: 1 1 280px;
      min-width: 310px;
      text-align: left;
      margin: 0.1rem;
      transform: translateZ(0);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .metric-card:hover {
      border-color: #2c7be5;
      box-shadow: 0 4px 12px rgba(44, 123, 229, 0.2);
      transform: translateY(-2px);
    }

    .metric-card h2 {
      font-size: 1.5rem;
      color: rgba(0, 0, 0, 0.6);
      margin: 0;
      font-weight: 400;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .metric-card .value {
      font-size: 3.25rem;
      font-weight: 700;
      color: #1e293b;
    }

    h2.section-title {
      text-align: left;
      font-size: 1.75rem;
      color: #2b2f32;
      margin: 3rem 0 1rem;
      font-weight: 300;
    }

    canvas {
      width: 100%;
      background: white;
      border-radius: 12px;
      padding: 1rem;
      border: 14px solid rgb(206, 206, 206);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }

    .loading-overlay.active {
      display: flex;
    }

    .loading-spinner {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .spinner {
      width: 50px;
      height: 50px;
      border: 4px solid #dbe2ea;
      border-top: 4px solid #2c7be5;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .loading-text {
      font-size: 1.2rem;
      color: #2b2f32;
      font-weight: 300;
    }

    .header-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-left: auto;
    }

    .export-button {
      padding: 0.75rem 1.5rem;
      background-color: #2c7be5;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      white-space: nowrap;
    }

    .export-button:hover {
      background-color: #1e5bb8;
    }

    .export-button:active {
      background-color: #164a94;
    }

    .export-button:disabled {
      background-color: #94a3b8;
      cursor: not-allowed;
    }

    #exportDropdownMenu button:hover {
      background-color: #f5f6f6;
    }

    .submeter-status-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      margin: 2rem 0;
      padding: 1rem;
      background: #f5f6f6;
      border-radius: 12px;
      border: 1px solid #dbe2ea;
    }

    .submeter-light {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: white;
      border-radius: 8px;
      border: 1px solid #dbe2ea;
    }

    .status-indicator {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
    }

    .status-indicator.active {
      background-color: #22c55e;
      box-shadow: 0 0 8px rgba(34, 197, 94, 0.5);
    }

    .status-indicator.inactive {
      background-color: #636262;
    }

    .status-indicator.loading {
      background-color: #94a3b8;
    }

    .submeter-label {
      font-size: 1rem;
      font-weight: 500;
      color: #2b2f32;
    }

    .metric-card-header {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .info-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background-color: #94a3b8;
      color: white;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: help;
      position: relative;
      flex-shrink: 0;
    }

    .info-icon:hover {
      background-color: #64748b;
    }

    .info-tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      bottom: 125%;
      left: 50%;
      transform: translateX(-50%);
      background-color: #1e293b;
      color: white;
      padding: 0.75rem;
      border-radius: 6px;
      font-size: 0.875rem;
      font-weight: 400;
      width: 250px;
      z-index: 1000;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
      transition: opacity 0.2s, visibility 0.2s;
      text-align: left;
      line-height: 1.4;
    }

    .info-tooltip::after {
      content: "";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: #1e293b transparent transparent transparent;
    }

    .info-icon:hover .info-tooltip {
      visibility: visible;
      opacity: 1;
    }

    /* Modal Styles */
    .modal {
      display: none;
      position: fixed;
      z-index: 10000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.5);
      animation: fadeIn 0.2s;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .modal.active {
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background-color: #fefefe;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      width: 90%;
      max-width: 1000px;
      max-height: 85vh;
      overflow-y: auto;
      animation: slideIn 0.3s;
    }

    @keyframes slideIn {
      from {
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
      padding-bottom: 1rem;
      border-bottom: 2px solid #dbe2ea;
    }

    .modal-header h2 {
      margin: 0;
      font-size: 1.75rem;
      font-weight: 300;
      color: #2b2f32;
    }

    .close-button {
      background: none;
      border: none;
      font-size: 2rem;
      font-weight: 300;
      color: #94a3b8;
      cursor: pointer;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .close-button:hover {
      background-color: #f5f6f6;
      color: #2b2f32;
    }

    .modal-chart-container {
      width: 100%;
      height: 400px;
      position: relative;
    }

    .modal-chart-container canvas {
      border: none;
      padding: 0;
    }
  </style>
</head>
<body>
  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner">
      <div class="spinner"></div>
      <div class="loading-text">Loading metrics...</div>
    </div>
  </div>

  <!-- Modal -->
  <div class="modal" id="metricModal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="modalTitle">Metric Details</h2>
        <button class="close-button" id="closeModal">&times;</button>
      </div>
      <div class="modal-chart-container">
        <canvas id="modalChart"></canvas>
      </div>
    </div>
  </div>

  <div class="header-banner">
    <h1>Nsight Fleet Charge Dashboard</h1>
  </div>

  <div class="dashboard-container">
    <!-- Submeter Status Lights -->
    <div class="submeter-status-container" id="submeterStatusContainer">
        Pedestal Status
      <div id="submeterLights" style="display: flex; flex-wrap: wrap; gap: 0.75rem; width: 100%;">
        <!-- Lights will be populated here -->
      </div>
    </div>  
    
    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.5rem; margin-top: 0.5rem;">
      <h1 style="margin: 0;">Lineage - Statesville eTRU Metrics</h1>
      <div style="position: relative;">
        <button id="exportDropdownButton" class="export-button" style="display: flex; align-items: center; gap: 0.5rem;">
          Export
          <span style="font-size: 0.8rem;">▼</span>
        </button>
        <div id="exportDropdownMenu" style="display: none; position: absolute; right: 0; top: 100%; margin-top: 0.25rem; background: white; border: 1px solid #dbe2ea; border-radius: 6px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); min-width: 250px; z-index: 1000;">
          <button id="exportKPIsButton" style="width: 100%; padding: 0.75rem 1rem; text-align: left; border: none; background: none; cursor: pointer; font-size: 1rem; border-bottom: 1px solid #dbe2ea; transition: background-color 0.2s;">
            Export Last 6 Months KPIs
          </button>
          <button id="exportSessionsButton" style="width: 100%; padding: 0.75rem 1rem; text-align: left; border: none; background: none; cursor: pointer; font-size: 1rem; transition: background-color 0.2s;">
            Export All Sessions for Selected Period
          </button>
        </div>
      </div>
    </div>

    <div class="facilitySelectorCommonComponent" style="margin-bottom: 0.5rem;">
      <label for="dateRange">Date Range:</label>
      <select id="dateRange" style="padding: 0.5rem; font-size: 1rem; border-radius: 6px; border: 1px solid #dbe2ea;">
        <option value="this-month">This Month</option>
        <option value="last-month">Last Month</option>
        <option value="last-7-days">Last 7 Days</option>
        <option value="last-30-days">Last 30 Days</option>
        <option value="last-90-days">Last 90 Days</option>
        <option value="ytd">Year to Date</option>
        <option value="custom">Custom Range</option>
      </select>
      
      <div id="customDateInputs" style="display: none; margin-left: 1rem;">
        <label for="customStart">From:</label>
        <input type="date" id="customStart" style="margin-left: 0.5rem; padding: 0.5rem;" />
        <label for="customEnd" style="margin-left: 1rem;">To:</label>
        <input type="date" id="customEnd" style="margin-left: 0.5rem; padding: 0.5rem;" />
      </div>
    </div>

    <!-- SECTION 1: eTRU Entry -->
    <div class="dashboard-section">
      <h2 class="section-header">eTRU Entry</h2>
      <div class="card-container">
        <div class="metric-card" data-metric="totalTrailers">
          <div class="metric-card-header">
            <h2>Total Trailers</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Total number of trailer appointments during the selected date range.</span>
            </span>
          </div>
          <div class="value" id="totalTrailers">Loading...</div>
        </div>
        <div class="metric-card" data-metric="etruTrailers">
          <div class="metric-card-header">
            <h2>eTRU Trailers</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Number of trailers equipped with electric Truck Refrigeration Units (eTRU) that checked in during the selected period.</span>
            </span>
          </div>
          <div class="value" id="count1">Loading...</div>
        </div>
        <div class="metric-card" data-metric="etruEnabledPercent">
          <div class="metric-card-header">
            <h2>eTRU-Enabled Trailer %</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Percentage of total trailer appointments that are eTRU-capable. Calculated as (eTRU Trailers / Total Trailers) × 100.</span>
            </span>
          </div>
          <div class="value" id="percentEtruEnabled">Loading...</div>
        </div>
      </div>
    </div>
    
    <!-- SECTION 2: eTRU Assignment -->
    <div class="dashboard-section">
      <h2 class="section-header">eTRU Assignment</h2>
      <div class="card-container">
        <div class="metric-card" data-metric="correctAssignments">
          <div class="metric-card-header">
            <h2>Correct eTRU Assignments</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Number of times eTRU-capable trailers were parked in yard spaces with charging infrastructure available.</span>
            </span>
          </div>
          <div class="value" id="correctAssignments">Loading...</div>
        </div>
        <div class="metric-card" data-metric="missedAssignments">
          <div class="metric-card-header">
            <h2>eTRU Missed Assignments</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Number of times eTRU-capable trailers were parked in yard spaces without charging infrastructure. These represent missed charging opportunities.</span>
            </span>
          </div>
          <div class="value" id="count2">Loading...</div>
        </div>
        <div class="metric-card" data-metric="assignmentRate">
          <div class="metric-card-header">
            <h2>eTRU Assignment Rate</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Percentage of eTRU trailers correctly assigned to charging-enabled spaces. Calculated as (Correct Assignments / Total Yard Sessions) × 100.</span>
            </span>
          </div>
          <div class="value" id="count3">Loading...</div>
        </div>
      </div>
    </div>
    
    <!-- SECTION 3: Charging Time -->
    <div class="dashboard-section">
      <h2 class="section-header">Charging Time</h2>
      <div class="card-container">
        <div class="metric-card" data-metric="assignedChargingTime">
          <div class="metric-card-header">
            <h2>Assigned Charging Time</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Total hours that charging sessions were associated with a specific customer during the selected period. Excludes sessions with 0 usage or duration less than 2 minutes.</span>
            </span>
          </div>
          <div class="value" id="assignedChargingTime">Loading...</div>
        </div>
        <div class="metric-card" data-metric="unassignedChargingTime">
          <div class="metric-card-header">
            <h2>Unassigned Charging Time</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Total hours of charging sessions that could not be attributed to a specific customer. Excludes sessions with 0 usage or duration less than 2 minutes.</span>
            </span>
          </div>
          <div class="value" id="unassignedChargingTime">Loading...</div>
        </div>
        <div class="metric-card" data-metric="totalChargingTime">
          <div class="metric-card-header">
            <h2>Total Charging Time</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Combined total of all charging session hours, both assigned and unassigned, during the selected period. Excludes sessions with 0 usage or duration less than 2 minutes.</span>
            </span>
          </div>
          <div class="value" id="totalChargingTime">Loading...</div>
        </div>
      </div>
    </div>

    <!-- SECTION 3.5: Charging Sessions -->
    <div class="dashboard-section">
      <h2 class="section-header">Charging Sessions</h2>
      <div class="card-container">
        <div class="metric-card" data-metric="numberOfSessions">
          <div class="metric-card-header">
            <h2>Number of Sessions</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Total number of charging sessions recorded during the selected period. Excludes sessions with 0 usage or duration less than 2 minutes.</span>
            </span>
          </div>
          <div class="value" id="numberOfSessions">Loading...</div>
        </div>
        <div class="metric-card" data-metric="averageSessionDuration">
          <div class="metric-card-header">
            <h2>Average Session Duration</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Average length of charging sessions, calculated as Total Charging Time divided by Number of Sessions. Excludes sessions with 0 usage or duration less than 2 minutes.</span>
            </span>
          </div>
          <div class="value" id="averageSessionDuration">Loading...</div>
        </div>
      </div>
    </div>
    
    <!-- SECTION 4: Consumption -->
    <div class="dashboard-section">
      <h2 class="section-header">Consumption</h2>
      <div class="card-container">
        <div class="metric-card" data-metric="totalAssignedUsage">
          <div class="metric-card-header">
            <h2>Total Assigned Usage</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Total energy consumption (kWh) from charging sessions that were associated with specific customers.</span>
            </span>
          </div>
          <div class="value" id="totalAssignedUsage">Loading...</div>
        </div>
        <div class="metric-card" data-metric="totalUnassignedUsage">
          <div class="metric-card-header">
            <h2>Total Unassigned Usage</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Energy consumption (kWh) from charging sessions that could not be attributed to specific customers.</span>
            </span>
          </div>
          <div class="value" id="totalUnassignedUsage">Loading...</div>
        </div>
        <div class="metric-card" data-metric="totalUsage">
          <div class="metric-card-header">
            <h2>Total Usage</h2>
            <span class="info-icon">
              i
              <span class="info-tooltip">Total energy consumption (kWh) from all submeters during the selected period, regardless of assignment status or association with a charging session.</span>
            </span>
          </div>
          <div class="value" id="totalUsage">Loading...</div>
        </div>
      </div>
    </div>
  </div>

<script>
  const dateRangeSelect = document.getElementById('dateRange');
  const customDateInputs = document.getElementById('customDateInputs');
  const customStartInput = document.getElementById('customStart');
  const customEndInput = document.getElementById('customEnd');

  const now = new Date();
  const todayStr = now.toISOString().split('T')[0];

  customStartInput.max = todayStr;
  customEndInput.max = todayStr;

  let lineChart;
  let dailyConsumptionChart;
  let modalChart;
  let currentDateRange = { start: '', end: '' };

  // Store raw data for modal charts
  let rawMetricData = {};

  // Restore saved date range selection on page load
  function restoreDateRangeSelection() {
    const savedRange = localStorage.getItem('etru_dateRange');
    const savedCustomStart = localStorage.getItem('etru_customStart');
    const savedCustomEnd = localStorage.getItem('etru_customEnd');
    
    if (savedRange) {
      dateRangeSelect.value = savedRange;
      
      if (savedRange === 'custom' && savedCustomStart && savedCustomEnd) {
        customDateInputs.style.display = 'inline-block';
        customStartInput.value = savedCustomStart;
        customEndInput.value = savedCustomEnd;
      }
    }
  }

  // Save date range selection to localStorage
  function saveDateRangeSelection() {
    localStorage.setItem('etru_dateRange', dateRangeSelect.value);
    
    if (dateRangeSelect.value === 'custom') {
      localStorage.setItem('etru_customStart', customStartInput.value);
      localStorage.setItem('etru_customEnd', customEndInput.value);
    }
  }

  // Call restore on page load
  restoreDateRangeSelection();

  // Modal functionality
  const modal = document.getElementById('metricModal');
  const modalTitle = document.getElementById('modalTitle');
  const closeModalBtn = document.getElementById('closeModal');

  closeModalBtn.onclick = function() {
    modal.classList.remove('active');
    if (modalChart) {
      modalChart.destroy();
      modalChart = null;
    }
  }

  window.onclick = function(event) {
    if (event.target == modal) {
      modal.classList.remove('active');
      if (modalChart) {
        modalChart.destroy();
        modalChart = null;
      }
    }
  }

  // Add click handlers to all metric cards
  document.addEventListener('click', function(e) {
    const card = e.target.closest('.metric-card');
    if (card && !e.target.closest('.info-icon')) {
      const metricType = card.getAttribute('data-metric');
      if (metricType) {
        openMetricModal(metricType);
      }
    }
  });

  // Dropdown menu functionality
  const exportDropdownButton = document.getElementById('exportDropdownButton');
  const exportDropdownMenu = document.getElementById('exportDropdownMenu');

  exportDropdownButton.addEventListener('click', (e) => {
    e.stopPropagation();
    exportDropdownMenu.style.display = exportDropdownMenu.style.display === 'none' ? 'block' : 'none';
  });

  document.addEventListener('click', () => {
    exportDropdownMenu.style.display = 'none';
  });

  exportDropdownMenu.addEventListener('click', (e) => {
    e.stopPropagation();
  });

  function getDateRange(rangeType) {
    const now = new Date();
    let startDate, endDate;

    switch(rangeType) {
      case 'last-month':
        startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        endDate = new Date(now.getFullYear(), now.getMonth(), 0);
        break;
      
      case 'this-month':
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        break;
      
      case 'last-7-days':
        endDate = new Date(now);
        endDate.setDate(endDate.getDate() + 1);
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - 7);
        break;
      
      case 'last-30-days':
        endDate = new Date(now);
        endDate.setDate(endDate.getDate() + 1);
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - 30);
        break;
      
      case 'last-90-days':
        endDate = new Date(now);
        endDate.setDate(endDate.getDate() + 1);
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - 90);
        break;
      
      case 'ytd':
        startDate = new Date(now.getFullYear(), 0, 1);
        endDate = new Date(now);
        endDate.setDate(endDate.getDate() + 1);
        break;
      
      case 'custom':
        return null;
      
      default:
        startDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        endDate = new Date(now.getFullYear(), now.getMonth(), 0);
    }

    return {
      start: startDate.toISOString().split('T')[0],
      end: endDate.toISOString().split('T')[0]
    };
  }

  dateRangeSelect.addEventListener('change', () => {
    const selectedRange = dateRangeSelect.value;
    
    if (selectedRange === 'custom') {
      customDateInputs.style.display = 'inline-block';
      
      if (!customStartInput.value || !customEndInput.value) {
        const lastMonth = getDateRange('last-month');
        customStartInput.value = lastMonth.start;
        customEndInput.value = lastMonth.end;
      }
    } else {
      customDateInputs.style.display = 'none';
      saveDateRangeSelection();
      updateFilters();
    }
  });

  customStartInput.addEventListener('change', () => {
    customEndInput.min = customStartInput.value;
    if (customEndInput.value && customEndInput.value < customStartInput.value) {
      customEndInput.value = customStartInput.value;
    }
    saveDateRangeSelection();
    updateFilters();
  });

  customEndInput.addEventListener('change', () => {
    saveDateRangeSelection();
    updateFilters();
  });

  function updateFilters() {
    const selectedRange = dateRangeSelect.value;
    let startDateStr, endDateStr;

    if (selectedRange === 'custom') {
      const today = new Date().toISOString().split('T')[0];
      
      if (!customStartInput.value || !customEndInput.value) {
        alert("Please select both start and end dates.");
        return;
      }
      
      if (customEndInput.value > today) {
        alert("End date cannot be in the future.");
        customEndInput.value = today;
        return;
      }
      
      if (customStartInput.value > today) {
        alert("Start date cannot be in the future.");
        customStartInput.value = today;
        return;
      }
      
      if (customEndInput.value < customStartInput.value) {
        alert("End date cannot be before start date.");
        return;
      }
      
      startDateStr = customStartInput.value;
      endDateStr = customEndInput.value;
    } else {
      const dateRange = getDateRange(selectedRange);
      startDateStr = dateRange.start;
      endDateStr = dateRange.end;
    }

    currentDateRange = { start: startDateStr, end: endDateStr };
    fetchMetrics(startDateStr, endDateStr);
  }

  function getTimeBucketSize(startDate, endDate) {
    const diffMs = new Date(endDate) - new Date(startDate);
    const diffDays = diffMs / (1000 * 60 * 60 * 24);
    
    if (diffDays > 365) {
      return 'year';
    } else if (diffDays > 90) {
      return 'month';
    } else {
      return 'day';
    }
  }

  function generateTimeBuckets(startDate, endDate, bucketSize) {
    const buckets = [];
    let current = new Date(startDate);
    const end = new Date(endDate);

    if (bucketSize === 'day') {
      while (current <= end) {
        buckets.push({
          start: new Date(current),
          end: new Date(current),
          label: current.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
        });
        current.setDate(current.getDate() + 1);
      }
    } else if (bucketSize === 'month') {
      current = new Date(current.getFullYear(), current.getMonth(), 1);
      while (current <= end) {
        const monthEnd = new Date(current.getFullYear(), current.getMonth() + 1, 0);
        buckets.push({
          start: new Date(current),
          end: monthEnd,
          label: current.toLocaleDateString('en-US', { month: 'short', year: 'numeric' })
        });
        current.setMonth(current.getMonth() + 1);
      }
    } else if (bucketSize === 'year') {
      current = new Date(current.getFullYear(), 0, 1);
      while (current <= end) {
        const yearEnd = new Date(current.getFullYear(), 11, 31);
        buckets.push({
          start: new Date(current),
          end: yearEnd,
          label: current.getFullYear().toString()
        });
        current.setFullYear(current.getFullYear() + 1);
      }
    }

    return buckets;
  }

  function openMetricModal(metricType) {
    const data = rawMetricData[metricType];
    if (!data) {
      console.error('No data available for metric:', metricType);
      return;
    }

    const metricTitles = {
      totalTrailers: 'Total Trailers Over Time',
      etruTrailers: 'eTRU Trailers Over Time',
      etruEnabledPercent: 'eTRU-Enabled Percentage Over Time',
      correctAssignments: 'Correct eTRU Assignments Over Time',
      missedAssignments: 'Missed eTRU Assignments Over Time',
      assignmentRate: 'Assignment Rate Over Time',
      assignedChargingTime: 'Assigned Charging Time Over Time',
      unassignedChargingTime: 'Unassigned Charging Time Over Time',
      totalChargingTime: 'Total Charging Time Over Time',
      numberOfSessions: 'Number of Sessions Over Time',
      averageSessionDuration: 'Average Session Duration Over Time',
      totalAssignedUsage: 'Total Assigned Usage Over Time',
      totalUnassignedUsage: 'Total Unassigned Usage Over Time',
      totalUsage: 'Total Energy Usage Over Time'
    };

    modalTitle.textContent = metricTitles[metricType] || 'Metric Over Time';
    modal.classList.add('active');

    if (modalChart) {
      modalChart.destroy();
    }

    const ctx = document.getElementById('modalChart').getContext('2d');
    modalChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: data.labels,
        datasets: [{
          label: metricTitles[metricType],
          data: data.values,
          borderColor: '#2c7be5',
          backgroundColor: 'rgba(44, 123, 229, 0.1)',
          borderWidth: 2,
          fill: true,
          tension: 0.3,
          pointBackgroundColor: '#2c7be5',
          pointRadius: 4,
          pointHoverRadius: 6
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            mode: 'index',
            intersect: false,
          }
        },
        scales: {
          y: {
            beginAtZero: true,
            ticks: {
              callback: function(value) {
                if (metricType.includes('Usage') || metricType === 'totalUsage') {
                  return value.toLocaleString() + ' kWh';
                } else if (metricType.includes('Time') || metricType.includes('Duration')) {
                  return value.toLocaleString() + ' hrs';
                } else if (metricType.includes('Percent') || metricType.includes('Rate')) {
                  return value + '%';
                }
                return value.toLocaleString();
              }
            }
          }
        }
      }
    });
  }

  function fetchMetrics(startDateStr, endDateStr) {
    const loadingOverlay = document.getElementById('loadingOverlay');
    loadingOverlay.classList.add('active');

    const isoStart = startDateStr;
    const isoEnd = endDateStr;

    let completedRequests = 0;
    const totalRequests = 3;

    function checkAllComplete() {
      completedRequests++;
      if (completedRequests >= totalRequests) {
        setTimeout(() => {
          loadingOverlay.classList.remove('active');
        }, 300);
      }
    }

    const trailerQuery = `
      query trailerApptsParkSess($filter: TrailerAppointmentFilter, $parkSessionFilter: ParkSessionFilter) {
        trailerAppointments(filter: $filter) {
          nodes {
            checkinTime
            trailer {
              carrierCode
              supportEtru
              parkSessions(filter: $parkSessionFilter) {
                nodes {
                  startTime
                  endTime
                  space {
                    etruEnabled
                    spaceCategory {
                      name
                    }
                  }
                }
              }
            }
          }
        }
      }
    `;

    fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: trailerQuery,
        variables: {
          filter: {
            checkinTime: { greaterThan: isoStart, lessThanOrEqualTo: isoEnd }
          },
          parkSessionFilter: {
            startTime: { greaterThan: isoStart }
          }
        }
      })
    })
    .then(res => res.json())
    .then(data => {
      const trailers = data?.data?.trailerAppointments?.nodes || [];
      
      document.getElementById('totalTrailers').textContent = trailers.length;
      
      const supportEtruCount = trailers.filter(t => t.trailer?.supportEtru).length;
      document.getElementById('count1').textContent = supportEtruCount;

      const totalAppointments = trailers.length;
      const etruPercent = totalAppointments
        ? Math.round((supportEtruCount / totalAppointments) * 100)
        : 0;
      document.getElementById('percentEtruEnabled').textContent = `${etruPercent}%`;

      // Calculate assignment metrics
      let yardSessionsWithoutEtru = 0;
      let totalYardSessions = 0;
      let etruYardSessions = 0;

      trailers.forEach(t => {
        if (!t.trailer?.supportEtru) return;
        (t.trailer.parkSessions.nodes || []).forEach(s => {
          if (s.space?.spaceCategory?.name?.toLowerCase() === 'yard') {
            totalYardSessions++;
            if (s.space.etruEnabled) {
              etruYardSessions++;
            } else {
              yardSessionsWithoutEtru++;
            }
          }
        });
      });

      document.getElementById('correctAssignments').textContent = etruYardSessions;
      document.getElementById('count2').textContent = yardSessionsWithoutEtru;
      
      const assignmentRate = totalYardSessions
        ? Math.round((etruYardSessions / totalYardSessions) * 100)
        : 0;
      document.getElementById('count3').textContent = `${assignmentRate}%`;

      // Generate time-series data for modal charts
      const bucketSize = getTimeBucketSize(isoStart, isoEnd);
      const buckets = generateTimeBuckets(isoStart, isoEnd, bucketSize);

      // Total Trailers over time
      const totalTrailersBuckets = buckets.map(b => ({ ...b, count: 0 }));
      trailers.forEach(t => {
        if (!t.checkinTime) return;
        const checkinDate = new Date(t.checkinTime);
        
        let bucketIndex = -1;
        for (let i = 0; i < buckets.length; i++) {
          const bucket = buckets[i];
          
          if (bucketSize === 'day') {
            const checkinDateOnly = new Date(checkinDate.getFullYear(), checkinDate.getMonth(), checkinDate.getDate());
            const bucketDateOnly = new Date(bucket.start.getFullYear(), bucket.start.getMonth(), bucket.start.getDate());
            
            if (checkinDateOnly.getTime() === bucketDateOnly.getTime()) {
              bucketIndex = i;
              break;
            }
          } else {
            const bucketStart = new Date(bucket.start);
            const bucketEnd = new Date(bucket.end);
            bucketEnd.setHours(23, 59, 59, 999);
            
            if (checkinDate >= bucketStart && checkinDate <= bucketEnd) {
              bucketIndex = i;
              break;
            }
          }
        }
        
        if (bucketIndex !== -1) {
          totalTrailersBuckets[bucketIndex].count++;
        }
      });

      rawMetricData.totalTrailers = {
        labels: totalTrailersBuckets.map(b => b.label),
        values: totalTrailersBuckets.map(b => b.count)
      };

      // eTRU Trailers over time
      const etruTrailersBuckets = buckets.map(b => ({ ...b, count: 0 }));
      trailers.filter(t => t.trailer?.supportEtru).forEach(t => {
        if (!t.checkinTime) return;
        const checkinDate = new Date(t.checkinTime);
        
        let bucketIndex = -1;
        for (let i = 0; i < buckets.length; i++) {
          const bucket = buckets[i];
          
          if (bucketSize === 'day') {
            const checkinDateOnly = new Date(checkinDate.getFullYear(), checkinDate.getMonth(), checkinDate.getDate());
            const bucketDateOnly = new Date(bucket.start.getFullYear(), bucket.start.getMonth(), bucket.start.getDate());
            
            if (checkinDateOnly.getTime() === bucketDateOnly.getTime()) {
              bucketIndex = i;
              break;
            }
          } else {
            const bucketStart = new Date(bucket.start);
            const bucketEnd = new Date(bucket.end);
            bucketEnd.setHours(23, 59, 59, 999);
            
            if (checkinDate >= bucketStart && checkinDate <= bucketEnd) {
              bucketIndex = i;
              break;
            }
          }
        }
        
        if (bucketIndex !== -1) {
          etruTrailersBuckets[bucketIndex].count++;
        }
      });

      rawMetricData.etruTrailers = {
        labels: etruTrailersBuckets.map(b => b.label),
        values: etruTrailersBuckets.map(b => b.count)
      };

      // eTRU Enabled Percentage over time
      rawMetricData.etruEnabledPercent = {
        labels: totalTrailersBuckets.map(b => b.label),
        values: totalTrailersBuckets.map((b, i) => {
          const total = b.count;
          const etru = etruTrailersBuckets[i].count;
          return total > 0 ? Math.round((etru / total) * 100) : 0;
        })
      };

      // Assignment metrics over time
      const correctAssignmentsBuckets = buckets.map(b => ({ ...b, count: 0 }));
      const missedAssignmentsBuckets = buckets.map(b => ({ ...b, count: 0 }));

      trailers.forEach(t => {
        if (!t.trailer?.supportEtru) return;
        (t.trailer.parkSessions.nodes || []).forEach(s => {
          if (s.space?.spaceCategory?.name?.toLowerCase() === 'yard' && s.endTime) {
            const endDate = new Date(s.endTime);
            
            let bucketIndex = -1;
            
            for (let i = 0; i < correctAssignmentsBuckets.length; i++) {
              const bucket = correctAssignmentsBuckets[i];
              
              if (bucketSize === 'day') {
                const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                const bucketDateOnly = new Date(bucket.start.getFullYear(), bucket.start.getMonth(), bucket.start.getDate());
                
                if (endDateOnly.getTime() === bucketDateOnly.getTime()) {
                  bucketIndex = i;
                  break;
                }
              } else {
                const dayStart = new Date(bucket.start);
                const dayEnd = new Date(bucket.end);
                dayEnd.setHours(23, 59, 59, 999);
                
                if (endDate >= dayStart && endDate <= dayEnd) {
                  bucketIndex = i;
                  break;
                }
              }
            }
            
            if (bucketIndex !== -1) {
              if (s.space.etruEnabled) {
                correctAssignmentsBuckets[bucketIndex].count++;
              } else {
                missedAssignmentsBuckets[bucketIndex].count++;
              }
            }
          }
        });
      });

      rawMetricData.correctAssignments = {
        labels: correctAssignmentsBuckets.map(b => b.label),
        values: correctAssignmentsBuckets.map(b => b.count)
      };

      rawMetricData.missedAssignments = {
        labels: missedAssignmentsBuckets.map(b => b.label),
        values: missedAssignmentsBuckets.map(b => b.count)
      };

      rawMetricData.assignmentRate = {
        labels: correctAssignmentsBuckets.map(b => b.label),
        values: correctAssignmentsBuckets.map((b, i) => {
          const total = b.count + missedAssignmentsBuckets[i].count;
          return total > 0 ? Math.round((b.count / total) * 100) : 0;
        })
      };

      checkAllComplete();
    })
    .catch(err => {
      console.error('Trailer metric fetch error:', err);
      checkAllComplete();
    });

    const facilityUsageQuery = `
      query submeterUsageWithAgg($from: String!, $to: String!) {
        submeters {
          usage(from: $from, to: $to, aggregation: SUM) {
            aggregates {
              SUM
            }
          }
        }
      }
    `;

    const totalUsagePromise = fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy-submeter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: facilityUsageQuery,
        variables: {
          from: isoStart.split('T')[0],
          to: isoEnd.split('T')[0]
        }
      })
    })
    .then(res => res.json())
    .then(data => {
      if (data.errors) {
        console.error('Facility usage query errors:', data.errors);
        document.getElementById('totalUsage').textContent = 'Error';
        checkAllComplete();
        return 0;
      }

      const totalFacilityUsage = data?.data?.submeters?.usage?.aggregates?.SUM || 0;
      document.getElementById('totalUsage').textContent = `${Math.round(totalFacilityUsage).toLocaleString()} kWh`;
      checkAllComplete();
      return totalFacilityUsage;
    })
    .catch(err => {
      console.error('Facility usage fetch error:', err);
      document.getElementById('totalUsage').textContent = 'Error';
      checkAllComplete();
      return 0;
    });

    // Fetch daily usage for modal chart
    const bucketSize = getTimeBucketSize(isoStart, isoEnd);
    let usageWindow = '1 day';
    if (bucketSize === 'month') {
      usageWindow = '1 month';
    } else if (bucketSize === 'year') {
      usageWindow = '1 year';
    }

    const dailyUsageQuery = `
      query dailyUsage($from: String!, $to: String!) {
        submeters {
          usage(
            from: $from
            to: $to
            aggregation: SUM
            window: "${usageWindow}"
            samplingWindow: "${usageWindow}"
          ) {
            nodes {
              time
              data
            }
          }
        }
      }
    `;

    fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy-submeter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: dailyUsageQuery,
        variables: {
          from: isoStart.split('T')[0],
          to: isoEnd.split('T')[0]
        }
      })
    })
    .then(res => res.json())
    .then(data => {
      const nodes = data?.data?.submeters?.usage?.nodes || [];
      const labels = [];
      const values = [];

      nodes.forEach(node => {
        const date = new Date(node.time);
        let label;
        if (bucketSize === 'day') {
          label = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', timeZone: 'UTC' });
        } else if (bucketSize === 'month') {
          label = date.toLocaleDateString('en-US', { month: 'short', year: 'numeric', timeZone: 'UTC' });
        } else {
          label = date.getFullYear().toString();
        }
        labels.push(label);
        values.push(Math.round(node.data));
      });

      rawMetricData.totalUsage = { labels, values };
    })
    .catch(err => console.error('Daily usage fetch error:', err));

    // Submeter status
    const statusNow = new Date();
    const statusFrom = new Date(statusNow.getTime() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];
    const statusTo = new Date(statusNow.getTime() + 24 * 60 * 60 * 1000).toISOString().split('T')[0];

    const submeterStatusQuery = `
      query submeterPoweredStatus($from: String!, $to: String!) {
        submeters {
          nodes {
            label
            usage {
              data(
                from: $from
                to: $to
                aggregation: MAX
                window: "15 minutes"
                samplingWindow: "15 minutes"
                last: 1
              ) {
                nodes {
                  data
                  time
                }
              }
            }
          }
        }
      }
    `;

    fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy-submeter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: submeterStatusQuery,
        variables: {
          from: statusFrom,
          to: statusTo
        }
      })
    })
    .then(res => res.json())
    .then(data => {
      const submeterNodes = data?.data?.submeters?.nodes || [];
      const lightsContainer = document.getElementById('submeterLights');
      lightsContainer.innerHTML = '';

      if (submeterNodes.length === 0) {
        lightsContainer.innerHTML = '<span style="color: #94a3b8;">No submeters found</span>';
      } else {
        const sortedSubmeters = [...submeterNodes].sort((a, b) => {
          const labelA = (a.label || 'Unknown').toLowerCase();
          const labelB = (b.label || 'Unknown').toLowerCase();
          return labelA.localeCompare(labelB);
        });

        sortedSubmeters.forEach(submeter => {
          const label = submeter.label || 'Unknown';
          const latestData = submeter.usage?.data?.nodes?.[0];
          const dataValue = latestData?.data;
          const isActive = dataValue !== undefined && dataValue > 0;

          const lightElement = document.createElement('div');
          lightElement.className = 'submeter-light';
          lightElement.innerHTML = `
            <div class="status-indicator ${isActive ? 'active' : 'inactive'}"></div>
            <span class="submeter-label">${label}</span>
          `;
          lightsContainer.appendChild(lightElement);
        });
      }
    })
    .catch(err => {
      console.error('Submeter status fetch error:', err);
      const lightsContainer = document.getElementById('submeterLights');
      lightsContainer.innerHTML = '<span style="color: #ef4444;">Error loading submeter status</span>';
    });

    // Submeter sessions
    const submeterQuery = `
      query subSess($filter: SubmeterSessionFilter) {
        submeterSessions(filter: $filter) {
          totalCount
          nodes {
            id
            startTime
            endTime
            associatedCustomerId
            usage { aggregates { SUM } }
          }
        }
      }
    `;

    fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy-submeter', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        query: submeterQuery,
        variables: {
          filter: {
            startTime: { greaterThanOrEqualTo: isoStart, lessThanOrEqualTo: isoEnd }
          }
        }
      })
    })
    .then(res => res.json())
    .then(async data => {
      const allSessions = data?.data?.submeterSessions?.nodes || [];
      
      // Filter out sessions with 0 usage or duration < 2 minutes
      const sessions = allSessions.filter(s => {
        const usage = s.usage?.aggregates?.SUM || 0;
        if (usage === 0) return false;
        
        if (s.startTime && s.endTime) {
          const durationMs = new Date(s.endTime) - new Date(s.startTime);
          const durationMinutes = durationMs / (1000 * 60);
          if (durationMinutes < 2) return false;
        }
        
        return true;
      });
      
      const totalSessionCount = sessions.length;

      let assignedDurationMs = 0;
      let unassignedDurationMs = 0;
      let totalDurationMs = 0;
      
      sessions.forEach(s => {
        if (s.startTime && s.endTime) {
          const duration = new Date(s.endTime) - new Date(s.startTime);
          totalDurationMs += duration;
          
          if (s.associatedCustomerId === null) {
            unassignedDurationMs += duration;
          } else {
            assignedDurationMs += duration;
          }
        }
      });
      
      const assignedHours = Math.round(assignedDurationMs / (1000 * 60 * 60));
      const unassignedHours = Math.round(unassignedDurationMs / (1000 * 60 * 60));
      const totalHours = Math.round(totalDurationMs / (1000 * 60 * 60));
      
      document.getElementById('assignedChargingTime').textContent = `${assignedHours.toLocaleString()} hrs`;
      document.getElementById('unassignedChargingTime').textContent = `${unassignedHours.toLocaleString()} hrs`;
      document.getElementById('totalChargingTime').textContent = `${totalHours.toLocaleString()} hrs`;

      document.getElementById('numberOfSessions').textContent = totalSessionCount.toLocaleString();
      
      const averageDurationHours = totalSessionCount > 0 
        ? (totalDurationMs / (1000 * 60 * 60)) / totalSessionCount 
        : 0;
      
      const avgHours = Math.floor(averageDurationHours);
      const avgMinutes = Math.round((averageDurationHours - avgHours) * 60);
      
      if (avgHours > 0) {
        document.getElementById('averageSessionDuration').textContent = `${avgHours}h ${avgMinutes}m`;
      } else {
        document.getElementById('averageSessionDuration').textContent = `${avgMinutes}m`;
      }

      let totalAssignedUsage = 0;
      let totalUnassignedUsage = 0;
      
      sessions.forEach(s => {
        const sessionUsage = s.usage?.aggregates?.SUM || 0;
        if (s.associatedCustomerId === null) {
          totalUnassignedUsage += sessionUsage;
        } else {
          totalAssignedUsage += sessionUsage;
        }
      });
      
      const roundedAssignedUsage = Math.round(totalAssignedUsage);
      const roundedUnassignedUsage = Math.round(totalUnassignedUsage);
      
      document.getElementById('totalAssignedUsage').textContent = `${roundedAssignedUsage.toLocaleString()} kWh`;
      document.getElementById('totalUnassignedUsage').textContent = `${roundedUnassignedUsage.toLocaleString()} kWh`;

      // Generate time-series data for charging time metrics
      const sessionBucketSize = getTimeBucketSize(isoStart, isoEnd);
      const sessionBuckets = generateTimeBuckets(isoStart, isoEnd, sessionBucketSize);
      
      const assignedTimeBuckets = sessionBuckets.map(b => ({ ...b, hours: 0 }));
      const unassignedTimeBuckets = sessionBuckets.map(b => ({ ...b, hours: 0 }));
      const totalTimeBuckets = sessionBuckets.map(b => ({ ...b, hours: 0 }));
      const sessionCountBuckets = sessionBuckets.map(b => ({ ...b, count: 0 }));
      const assignedUsageBuckets = sessionBuckets.map(b => ({ ...b, kwh: 0 }));
      const unassignedUsageBuckets = sessionBuckets.map(b => ({ ...b, kwh: 0 }));

      sessions.forEach(s => {
        const endTime = s.endTime ? new Date(s.endTime) : null;
        if (!endTime) return;
        
        let bucketIndex = -1;
        
        for (let i = 0; i < sessionBuckets.length; i++) {
          const bucket = sessionBuckets[i];
          
          if (sessionBucketSize === 'day') {
            const endDateOnly = new Date(endTime.getFullYear(), endTime.getMonth(), endTime.getDate());
            const bucketDateOnly = new Date(bucket.start.getFullYear(), bucket.start.getMonth(), bucket.start.getDate());
            
            if (endDateOnly.getTime() === bucketDateOnly.getTime()) {
              bucketIndex = i;
              break;
            }
          } else {
            const dayStart = new Date(bucket.start);
            const dayEnd = new Date(bucket.end);
            dayEnd.setHours(23, 59, 59, 999);
            
            if (endTime >= dayStart && endTime <= dayEnd) {
              bucketIndex = i;
              break;
            }
          }
        }
        
        if (bucketIndex !== -1) {
          sessionCountBuckets[bucketIndex].count++;
          
          if (s.startTime && s.endTime) {
            const durationHours = (new Date(s.endTime) - new Date(s.startTime)) / (1000 * 60 * 60);
            totalTimeBuckets[bucketIndex].hours += durationHours;
            
            if (s.associatedCustomerId === null) {
              unassignedTimeBuckets[bucketIndex].hours += durationHours;
            } else {
              assignedTimeBuckets[bucketIndex].hours += durationHours;
            }
          }

          const usage = s.usage?.aggregates?.SUM || 0;
          if (s.associatedCustomerId === null) {
            unassignedUsageBuckets[bucketIndex].kwh += usage;
          } else {
            assignedUsageBuckets[bucketIndex].kwh += usage;
          }
        }
      });

      rawMetricData.assignedChargingTime = {
        labels: assignedTimeBuckets.map(b => b.label),
        values: assignedTimeBuckets.map(b => Math.round(b.hours))
      };

      rawMetricData.unassignedChargingTime = {
        labels: unassignedTimeBuckets.map(b => b.label),
        values: unassignedTimeBuckets.map(b => Math.round(b.hours))
      };

      rawMetricData.totalChargingTime = {
        labels: totalTimeBuckets.map(b => b.label),
        values: totalTimeBuckets.map(b => Math.round(b.hours))
      };

      rawMetricData.numberOfSessions = {
        labels: sessionCountBuckets.map(b => b.label),
        values: sessionCountBuckets.map(b => b.count)
      };

      rawMetricData.averageSessionDuration = {
        labels: sessionCountBuckets.map(b => b.label),
        values: sessionCountBuckets.map((b, i) => {
          return b.count > 0 ? (totalTimeBuckets[i].hours / b.count) : 0;
        }).map(v => Math.round(v * 10) / 10)
      };

      rawMetricData.totalAssignedUsage = {
        labels: assignedUsageBuckets.map(b => b.label),
        values: assignedUsageBuckets.map(b => Math.round(b.kwh))
      };

      rawMetricData.totalUnassignedUsage = {
        labels: unassignedUsageBuckets.map(b => b.label),
        values: unassignedUsageBuckets.map(b => Math.round(b.kwh))
      };

      checkAllComplete();
    })
    .catch(err => {
      console.error('Submeter fetch error:', err);
      checkAllComplete();
    });
  }

  // Export functionality
  document.getElementById('exportKPIsButton').addEventListener('click', async () => {
    exportDropdownMenu.style.display = 'none';
    
    // Calculate last 6 months
    const endDate = new Date();
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - 6);
    
    const isoStart = startDate.toISOString().split('T')[0];
    const isoEnd = endDate.toISOString().split('T')[0];
    
    loadingOverlay.classList.add('active');
    
    try {
      // Fetch trailer data
      const trailerQuery = `
        query trailerApptsParkSess($filter: TrailerAppointmentFilter, $parkSessionFilter: ParkSessionFilter) {
          trailerAppointments(filter: $filter) {
            nodes {
              checkinTime
              trailer {
                carrierCode
                supportEtru
                parkSessions(filter: $parkSessionFilter) {
                  nodes {
                    startTime
                    endTime
                    space {
                      etruEnabled
                      spaceCategory {
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      `;
      
      const trailerResponse = await fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: trailerQuery,
          variables: {
            filter: {
              checkinTime: { greaterThan: isoStart, lessThanOrEqualTo: isoEnd }
            },
            parkSessionFilter: {
              startTime: { greaterThan: isoStart }
            }
          }
        })
      });
      
      const trailerData = await trailerResponse.json();
      const trailers = trailerData?.data?.trailerAppointments?.nodes || [];
      
      // Fetch submeter sessions
      const submeterQuery = `
        query subSess($filter: SubmeterSessionFilter) {
          submeterSessions(filter: $filter) {
            totalCount
            nodes {
              id
              startTime
              endTime
              associatedCustomerId
              usage { aggregates { SUM } }
            }
          }
        }
      `;
      
      const submeterResponse = await fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy-submeter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: submeterQuery,
          variables: {
            filter: {
              startTime: { greaterThanOrEqualTo: isoStart, lessThanOrEqualTo: isoEnd }
            }
          }
        })
      });
      
      const submeterData = await submeterResponse.json();
      const allSessions = submeterData?.data?.submeterSessions?.nodes || [];
      
      // Apply session filters
      const sessions = allSessions.filter(s => {
        const usage = s.usage?.aggregates?.SUM || 0;
        if (usage === 0) return false;
        
        if (s.startTime && s.endTime) {
          const durationMs = new Date(s.endTime) - new Date(s.startTime);
          const durationMinutes = durationMs / (1000 * 60);
          if (durationMinutes < 2) return false;
        }
        
        return true;
      });
      
      const totalSessionCount = sessions.length;
      
      // Fetch facility usage
      const facilityUsageQuery = `
        query submeterUsageWithAgg($from: String!, $to: String!) {
          submeters {
            usage(from: $from, to: $to, aggregation: SUM) {
              aggregates {
                SUM
              }
            }
          }
        }
      `;
      
      const facilityResponse = await fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy-submeter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: facilityUsageQuery,
          variables: {
            from: isoStart,
            to: isoEnd
          }
        })
      });
      
      const facilityData = await facilityResponse.json();
      const totalFacilityUsage = facilityData?.data?.submeters?.usage?.aggregates?.SUM || 0;
      
      // Calculate KPIs
      const totalTrailers = trailers.length;
      const etruTrailers = trailers.filter(t => t.trailer?.supportEtru).length;
      const etruPercent = totalTrailers > 0 ? Math.round((etruTrailers / totalTrailers) * 100) : 0;
      
      let correctAssignments = 0;
      let missedAssignments = 0;
      let totalYardSessions = 0;
      
      trailers.forEach(t => {
        if (!t.trailer?.supportEtru) return;
        (t.trailer.parkSessions.nodes || []).forEach(s => {
          if (s.space?.spaceCategory?.name?.toLowerCase() === 'yard') {
            totalYardSessions++;
            if (s.space.etruEnabled) {
              correctAssignments++;
            } else {
              missedAssignments++;
            }
          }
        });
      });
      
      const assignmentRate = totalYardSessions > 0 ? Math.round((correctAssignments / totalYardSessions) * 100) : 0;
      
      let assignedDurationMs = 0;
      let unassignedDurationMs = 0;
      let totalDurationMs = 0;
      let totalAssignedUsage = 0;
      let totalUnassignedUsage = 0;
      
      sessions.forEach(s => {
        if (s.startTime && s.endTime) {
          const duration = new Date(s.endTime) - new Date(s.startTime);
          totalDurationMs += duration;
          
          if (s.associatedCustomerId === null) {
            unassignedDurationMs += duration;
          } else {
            assignedDurationMs += duration;
          }
        }
        
        const sessionUsage = s.usage?.aggregates?.SUM || 0;
        if (s.associatedCustomerId === null) {
          totalUnassignedUsage += sessionUsage;
        } else {
          totalAssignedUsage += sessionUsage;
        }
      });
      
      const assignedHours = Math.round(assignedDurationMs / (1000 * 60 * 60));
      const unassignedHours = Math.round(unassignedDurationMs / (1000 * 60 * 60));
      const totalHours = Math.round(totalDurationMs / (1000 * 60 * 60));
      
      const averageDurationHours = totalSessionCount > 0 ? (totalDurationMs / (1000 * 60 * 60)) / totalSessionCount : 0;
      const avgHours = Math.floor(averageDurationHours);
      const avgMinutes = Math.round((averageDurationHours - avgHours) * 60);
      const avgDurationStr = avgHours > 0 ? `${avgHours}h ${avgMinutes}m` : `${avgMinutes}m`;
      
      // Create CSV
      const csvContent = [
        ['Lineage - Statesville eTRU KPIs'],
        ['Period', `${isoStart} to ${isoEnd}`],
        ['Generated', new Date().toLocaleString()],
        ['Note', 'Sessions exclude those with 0 usage or duration < 2 minutes'],
        [],
        ['Metric', 'Value'],
        ['Total Trailers', totalTrailers],
        ['eTRU Trailers', etruTrailers],
        ['eTRU-Enabled Trailer %', `${etruPercent}%`],
        ['Correct eTRU Assignments', correctAssignments],
        ['eTRU Missed Assignments', missedAssignments],
        ['eTRU Assignment Rate', `${assignmentRate}%`],
        ['Assigned Charging Time', `${assignedHours} hrs`],
        ['Unassigned Charging Time', `${unassignedHours} hrs`],
        ['Total Charging Time', `${totalHours} hrs`],
        ['Number of Sessions', totalSessionCount],
        ['Average Session Duration', avgDurationStr],
        ['Total Assigned Usage', `${Math.round(totalAssignedUsage)} kWh`],
        ['Total Unassigned Usage', `${Math.round(totalUnassignedUsage)} kWh`],
        ['Total Usage (Facility)', `${Math.round(totalFacilityUsage)} kWh`]
      ].map(row => row.join(',')).join('\n');
      
      // Download CSV
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `eTRU_KPIs_Last_6_Months_${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
    } catch (error) {
      console.error('Export KPIs error:', error);
      alert('Error exporting KPIs. Please try again.');
    } finally {
      loadingOverlay.classList.remove('active');
    }
  });

  document.getElementById('exportSessionsButton').addEventListener('click', async () => {
    exportDropdownMenu.style.display = 'none';
    
    if (!currentDateRange.start || !currentDateRange.end) {
      alert('Please select a date range first.');
      return;
    }
    
    loadingOverlay.classList.add('active');
    
    try {
      const submeterQuery = `
        query subSess($filter: SubmeterSessionFilter) {
          submeterSessions(filter: $filter) {
            nodes {
              id
              startTime
              endTime
              associatedCustomerId
              associatedCustomer {
                name
              }
              usage { aggregates { SUM } }
              submeter {
                label
              }
            }
          }
        }
      `;
      
      const response = await fetch('https://lin-statesville-etru-dash-proxy.onrender.com/proxy-submeter', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          query: submeterQuery,
          variables: {
            filter: {
              startTime: { greaterThanOrEqualTo: currentDateRange.start, lessThanOrEqualTo: currentDateRange.end }
            }
          }
        })
      });
      
      const data = await response.json();
      const allSessions = data?.data?.submeterSessions?.nodes || [];
      
      // Apply the same filters as in the dashboard
      const sessions = allSessions.filter(s => {
        const usage = s.usage?.aggregates?.SUM || 0;
        if (usage === 0) return false;
        
        if (s.startTime && s.endTime) {
          const durationMs = new Date(s.endTime) - new Date(s.startTime);
          const durationMinutes = durationMs / (1000 * 60);
          if (durationMinutes < 2) return false;
        }
        
        return true;
      });
      
      if (sessions.length === 0) {
        alert('No sessions found for the selected period (after filtering).');
        loadingOverlay.classList.remove('active');
        return;
      }
      
      // Create CSV header
      const csvRows = [
        ['Session ID', 'Submeter', 'Start Time', 'End Time', 'Duration (hours)', 'Customer', 'Usage (kWh)']
      ];
      
      sessions.forEach(session => {
        const startTime = session.startTime || '';
        const endTime = session.endTime || '';
        const durationHours = (startTime && endTime) 
          ? ((new Date(endTime) - new Date(startTime)) / (1000 * 60 * 60)).toFixed(2)
          : '';
        const customer = session.associatedCustomer?.name || 'Unassigned';
        const usage = session.usage?.aggregates?.SUM ? Math.round(session.usage.aggregates.SUM) : 0;
        const submeter = session.submeter?.label || 'Unknown';
        
        csvRows.push([
          session.id,
          submeter,
          startTime,
          endTime,
          durationHours,
          customer,
          usage
        ]);
      });
      
      const csvContent = csvRows.map(row => 
        row.map(cell => `"${cell}"`).join(',')
      ).join('\n');
      
      // Download CSV
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `eTRU_Sessions_${currentDateRange.start}_to_${currentDateRange.end}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
    } catch (error) {
      console.error('Export sessions error:', error);
      alert('Error exporting sessions. Please try again.');
    } finally {
      loadingOverlay.classList.remove('active');
    }
  });

  // Initial load
  updateFilters();
</script>
</body>
</html>
